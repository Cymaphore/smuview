/*
 * This file is part of the SmuView project.
 *
 * Copyright (C) 2012-2015 Joel Holdsworth <joel@airwebreathe.org.uk>
 * Copyright (C) 2017 Frank Stettner <frank-stettner@gmx.net>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, see <http://www.gnu.org/licenses/>.
 */

#include <extdef.h>

#include <algorithm>
#include <cassert>

#include <QAction>
#include <QDebug>
#include <QFileDialog>
#include <QHelpEvent>
#include <QMenu>
#include <QMessageBox>
#include <QSettings>
#include <QToolTip>

#include <boost/algorithm/string/join.hpp>

#include <libsigrokcxx/libsigrokcxx.hpp>

#include "maintoolbar.hpp"
#include "src/devicemanager.hpp"
#include "src/devices/hardwaredevice.hpp"
//#include "src/devices/inputfile.hpp"
//#include "src/devices/sessionfile.hpp"
#include "src/dialogs/connect.hpp"
//#include "src/dialogs/inputoutputoptions.hpp"
//#include "src/dialogs/storeprogress.hpp"
#include "src/mainwindow.hpp"
//#include "src/popups/channels.hpp"
//#include "src/popups/deviceoptions.hpp"
#include "src/util.hpp"
//#include "src/views/trace/view.hpp"
//#include "src/widgets/exportmenu.hpp"
//#include "src/widgets/importmenu.hpp"


using std::back_inserter;
using std::copy;
using std::list;
using std::make_pair;
using std::map;
using std::max;
using std::min;
using std::pair;
using std::set;
using std::shared_ptr;
using std::string;
using std::vector;

using sigrok::Capability;
using sigrok::ConfigKey;
using sigrok::Error;
using sigrok::InputFormat;
using sigrok::OutputFormat;

using boost::algorithm::join;

namespace sv {
namespace toolbars {

const char *MainToolBar::SettingOpenDirectory = "MainWindow/OpenDirectory";
const char *MainToolBar::SettingSaveDirectory = "MainWindow/SaveDirectory";

MainToolBar::MainToolBar(Session &session, QWidget *parent) :
	QToolBar("Main Toolbar", parent),
	session_(session),
	action_new_view_(new QAction(this)),
	//action_open_(new QAction(this)),
	//action_save_as_(new QAction(this)),
	//action_save_selection_as_(new QAction(this)),
	action_connect_(new QAction(this))//,
	//open_button_(new QToolButton()),
	//save_button_(new QToolButton()),
	//device_selector_(parent, session.device_manager(),
	//	action_connect_),
	//configure_button_(this),
	//configure_button_action_(nullptr)
{
	setObjectName(QString::fromUtf8("MainToolBar"));

	setContextMenuPolicy(Qt::PreventContextMenu);

	// Actions
	action_new_view_->setText(tr("New &View"));
	action_new_view_->setIcon(QIcon::fromTheme("window-new",
		QIcon(":/icons/window-new.png")));
	connect(action_new_view_, SIGNAL(triggered(bool)),
		this, SLOT(on_actionNewView_triggered()));

	/*
	action_open_->setText(tr("&Open..."));
	action_open_->setIcon(QIcon::fromTheme("document-open",
		QIcon(":/icons/document-open.png")));
	action_open_->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_O));
	connect(action_open_, SIGNAL(triggered(bool)),
		this, SLOT(on_actionOpen_triggered()));

	action_save_as_->setText(tr("&Save As..."));
	action_save_as_->setIcon(QIcon::fromTheme("document-save-as",
		QIcon(":/icons/document-save-as.png")));
	action_save_as_->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_S));
	connect(action_save_as_, SIGNAL(triggered(bool)),
		this, SLOT(on_actionSaveAs_triggered()));

	action_save_selection_as_->setText(tr("Save Selected &Range As..."));
	action_save_selection_as_->setIcon(QIcon::fromTheme("document-save-as",
		QIcon(":/icons/document-save-as.png")));
	action_save_selection_as_->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_R));
	connect(action_save_selection_as_, SIGNAL(triggered(bool)),
		this, SLOT(on_actionSaveSelectionAs_triggered()));

	widgets::ExportMenu *menu_file_export = new widgets::ExportMenu(this,
		session.device_manager().context());
	menu_file_export->setTitle(tr("&Export"));
	connect(menu_file_export,
		SIGNAL(format_selected(shared_ptr<sigrok::OutputFormat>)),
		this, SLOT(export_file(shared_ptr<sigrok::OutputFormat>)));

	widgets::ImportMenu *menu_file_import = new widgets::ImportMenu(this,
		session.device_manager().context());
	menu_file_import->setTitle(tr("&Import"));
	connect(menu_file_import,
		SIGNAL(format_selected(shared_ptr<sigrok::InputFormat>)),
		this, SLOT(import_file(shared_ptr<sigrok::InputFormat>)));
	*/

	action_connect_->setText(tr("&Connect to Device..."));
	connect(action_connect_, SIGNAL(triggered(bool)),
		this, SLOT(on_actionConnect_triggered()));

	// Open button
	/*
	widgets::ImportMenu *import_menu = new widgets::ImportMenu(this,
		session.device_manager().context(), action_open_);
	connect(import_menu,
		SIGNAL(format_selected(shared_ptr<sigrok::InputFormat>)),
		this,
		SLOT(import_file(shared_ptr<sigrok::InputFormat>)));

	open_button_->setMenu(import_menu);
	open_button_->setDefaultAction(action_open_);
	open_button_->setPopupMode(QToolButton::MenuButtonPopup);

	// Save button
	vector<QAction *> open_actions;
	open_actions.push_back(action_save_as_);
	open_actions.push_back(action_save_selection_as_);

	widgets::ExportMenu *export_menu = new widgets::ExportMenu(this,
		session.device_manager().context(),
		open_actions);
	connect(export_menu,
		SIGNAL(format_selected(shared_ptr<sigrok::OutputFormat>)),
		this,
		SLOT(export_file(shared_ptr<sigrok::OutputFormat>)));

	save_button_->setMenu(export_menu);
	save_button_->setDefaultAction(action_save_as_);
	save_button_->setPopupMode(QToolButton::MenuButtonPopup);

	// Device selector menu
	connect(&device_selector_, SIGNAL(device_selected()),
		this, SLOT(on_device_selected()));
	*/

	set_capture_state(sv::Session::Stopped);

	/*
	configure_button_.setToolTip(tr("Configure Device"));
	configure_button_.setIcon(QIcon::fromTheme("preferences-system",
		QIcon(":/icons/preferences-system.png")));
	*/

	add_toolbar_widgets();

	// Setup session_ events
	connect(&session_, SIGNAL(capture_state_changed(int)),
		this, SLOT(on_capture_state_changed(int)));
	connect(&session, SIGNAL(device_changed()),
		this, SLOT(on_device_changed()));

	update_device_list();
}

void MainToolBar::update_device_list()
{
	/*
	DeviceManager &mgr = session_.device_manager();
	shared_ptr<devices::Device> selected_device = session_.device();
	list< shared_ptr<devices::Device> > devs;

	copy(mgr.devices().begin(), mgr.devices().end(), back_inserter(devs));

	if (std::find(devs.begin(), devs.end(), selected_device) == devs.end())
		devs.push_back(selected_device);

	device_selector_.set_device_list(devs, selected_device);
	update_device_config_widgets();
	*/
}

void MainToolBar::set_capture_state(sv::Session::capture_state state)
{
	bool ui_enabled = (state == sv::Session::Stopped) ? true : false;

	ui_enabled |= ui_enabled;
	/*
	device_selector_.setEnabled(ui_enabled);
	configure_button_.setEnabled(ui_enabled);
	*/
}

void MainToolBar::reset_device_selector()
{
	//device_selector_.reset();
}

/*
QAction* MainToolBar::action_open() const
{
	return action_open_;
}

QAction* MainToolBar::action_save_as() const
{
	return action_save_as_;
}

QAction* MainToolBar::action_save_selection_as() const
{
	return action_save_selection_as_;
}
*/

QAction* MainToolBar::action_connect() const
{
	return action_connect_;
}

void MainToolBar::update_device_config_widgets()
{
	/*
	using namespace sv::popups;

	const shared_ptr<devices::Device> device =
		device_selector_.selected_device();

	// Hide the widgets if no device is selected
	channels_button_action_->setVisible(!!device);
	if (!device) {
		configure_button_action_->setVisible(false);
		sample_count_.show_none();
		sample_rate_.show_none();
		return;
	}

	const shared_ptr<sigrok::Device> sr_dev = device->device();
	if (!sr_dev)
		return;

	// Update the configure popup
	DeviceOptions *const opts = new DeviceOptions(sr_dev, this);
	configure_button_action_->setVisible(
		!opts->binding().properties().empty());
	configure_button_.set_popup(opts);

	// Update the channels popup
	Channels *const channels = new Channels(session_, this);
	channels_button_.set_popup(channels);

	// Update supported options.
	sample_count_supported_ = false;

	if (sr_dev->config_check(ConfigKey::LIMIT_SAMPLES, Capability::SET))
		sample_count_supported_ = true;

	if (sr_dev->config_check(ConfigKey::LIMIT_FRAMES, Capability::SET)) {
		sr_dev->config_set(ConfigKey::LIMIT_FRAMES,
			Glib::Variant<guint64>::create(1));
			on_config_changed();
	}

	// Add notification of reconfigure events
	disconnect(this, SLOT(on_config_changed()));
	connect(&opts->binding(), SIGNAL(config_changed()),
		this, SLOT(on_config_changed()));

	// Update sweep timing widgets.
	update_sample_count_selector();
	update_sample_rate_selector();
	*/
}

void MainToolBar::session_error(const QString text, const QString info_text)
{
	QMetaObject::invokeMethod(this, "show_session_error",
		Qt::QueuedConnection, Q_ARG(QString, text),
		Q_ARG(QString, info_text));
}

void MainToolBar::show_session_error(const QString text, const QString info_text)
{
	QMessageBox msg(this);
	msg.setText(text);
	msg.setInformativeText(info_text);
	msg.setStandardButtons(QMessageBox::Ok);
	msg.setIcon(QMessageBox::Warning);
	msg.exec();
}

/*
void MainToolBar::export_file(shared_ptr<OutputFormat> format, bool selection_only)
{
	using sv::dialogs::StoreProgress;

	// Stop any currently running capture session
	session_.stop_capture();

	QSettings settings;
	const QString dir = settings.value(SettingSaveDirectory).toString();

	pair<uint64_t, uint64_t> sample_range;

	// Selection only? Verify that the cursors are active and fetch their values
	if (selection_only) {
		views::trace::View *trace_view =
			qobject_cast<views::trace::View*>(session_.main_view().get());

		if (!trace_view->cursors()->enabled()) {
			show_session_error(tr("Missing Cursors"), tr("You need to set the " \
					"cursors before you can save the data enclosed by them " \
					"to a session file (e.g. using the Show Cursors button)."));
			return;
		}

		const double samplerate = session_.get_samplerate();

		const sv::util::Timestamp& start_time = trace_view->cursors()->first()->time();
		const sv::util::Timestamp& end_time = trace_view->cursors()->second()->time();

		const uint64_t start_sample = (uint64_t)max(
			(double)0, start_time.convert_to<double>() * samplerate);
		const uint64_t end_sample = (uint64_t)max(
			(double)0, end_time.convert_to<double>() * samplerate);

		sample_range = make_pair(start_sample, end_sample);
	} else {
		sample_range = make_pair(0, 0);
	}

	// Construct the filter
	const vector<string> exts = format->extensions();
	QString filter = tr("%1 files ").arg(
		QString::fromStdString(format->description()));

	if (exts.empty())
		filter += "(*)";
	else
		filter += QString("(*.%1);;%2 (*)").arg(
			QString::fromStdString(join(exts, ", *.")),
			tr("All Files"));

	// Show the file dialog
	const QString file_name = QFileDialog::getSaveFileName(
		this, tr("Save File"), dir, filter);

	if (file_name.isEmpty())
		return;

	const QString abs_path = QFileInfo(file_name).absolutePath();
	settings.setValue(SettingSaveDirectory, abs_path);

	// Show the options dialog
	map<string, Glib::VariantBase> options;
	if (!format->options().empty()) {
		dialogs::InputOutputOptions dlg(
			tr("Export %1").arg(QString::fromStdString(
				format->description())),
			format->options(), this);
		if (!dlg.exec())
			return;
		options = dlg.options();
	}

	if (!selection_only)
		session_.set_name(QFileInfo(file_name).fileName());

	StoreProgress *dlg = new StoreProgress(file_name, format, options,
		sample_range, session_, this);
	dlg->run();
}

void MainToolBar::import_file(shared_ptr<InputFormat> format)
{
	assert(format);

	QSettings settings;
	const QString dir = settings.value(SettingOpenDirectory).toString();

	// Construct the filter
	const vector<string> exts = format->extensions();
	const QString filter = exts.empty() ? "" :
		tr("%1 files (*.%2)").arg(
			QString::fromStdString(format->description()),
			QString::fromStdString(join(exts, ", *.")));

	// Show the file dialog
	const QString file_name = QFileDialog::getOpenFileName(
		this, tr("Import File"), dir, tr(
			"%1 files (*);;All Files (*)").arg(
			QString::fromStdString(format->description())));

	if (file_name.isEmpty())
		return;

	// Show the options dialog
	map<string, Glib::VariantBase> options;
	if (!format->options().empty()) {
		dialogs::InputOutputOptions dlg(
			tr("Import %1").arg(QString::fromStdString(
				format->description())),
			format->options(), this);
		if (!dlg.exec())
			return;
		options = dlg.options();
	}

	session_.load_file(file_name, format, options);

	const QString abs_path = QFileInfo(file_name).absolutePath();
	settings.setValue(SettingOpenDirectory, abs_path);
}
*/

void MainToolBar::on_capture_state_changed(int state)
{
	set_capture_state((sv::Session::capture_state)state);
}

void MainToolBar::on_config_changed()
{
}

void MainToolBar::on_actionNewView_triggered()
{
	new_view(&session_);
}

/*
void MainToolBar::on_actionOpen_triggered()
{
	QSettings settings;
	const QString dir = settings.value(SettingOpenDirectory).toString();

	// Show the dialog
	const QString file_name = QFileDialog::getOpenFileName(
		this, tr("Open File"), dir, tr(
			"sigrok Sessions (*.sr);;"
			"All Files (*)"));

	if (!file_name.isEmpty()) {
		session_.load_file(file_name);

		const QString abs_path = QFileInfo(file_name).absolutePath();
		settings.setValue(SettingOpenDirectory, abs_path);
	}
}

void MainToolBar::on_actionSaveAs_triggered()
{
	export_file(session_.device_manager().context()->output_formats()["srzip"]);
}

void MainToolBar::on_actionSaveSelectionAs_triggered()
{
	export_file(session_.device_manager().context()->output_formats()["srzip"], true);
}
*/

void MainToolBar::on_actionConnect_triggered()
{
	// Stop any currently running capture session
	session_.stop_capture();

	dialogs::Connect dlg(this, session_.device_manager());

	// If the user selected a device, select it in the device list. Select the
	// current device otherwise.
	if (dlg.exec())
		session_.select_device(dlg.get_selected_device());

	update_device_list();
}

void MainToolBar::add_toolbar_widgets()
{
	addAction(action_new_view_);
	addSeparator();
	/*
	addWidget(open_button_);
	addWidget(save_button_);
	addSeparator();

	StandardBar::add_toolbar_widgets();

	addWidget(&device_selector_);
	configure_button_action_ = addWidget(&configure_button_);
	channels_button_action_ = addWidget(&channels_button_);
	addWidget(&sample_count_);
	addWidget(&sample_rate_);
	*/
}

bool MainToolBar::eventFilter(QObject *watched, QEvent *event)
{
	/*
	if (sample_count_supported_ && (watched == &sample_count_ ||
			watched == &sample_rate_) &&
			(event->type() == QEvent::ToolTip)) {
		auto sec = sv::util::Timestamp(sample_count_.value()) / sample_rate_.value();
		QHelpEvent *help_event = static_cast<QHelpEvent*>(event);

		QString str = tr("Total sampling time: %1").arg(
			sv::util::format_time_si(sec, sv::util::SIPrefix::unspecified, 0, "s", false));
		QToolTip::showText(help_event->globalPos(), str);

		return true;
	}
	*/

	return false;
}

} // namespace toolbars
} // namespace sv
